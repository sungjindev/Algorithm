#include <iostream>
using namespace std;

//일단 문제부터 이해해보자.
//가장 왼쪽의 계란부터 들어서 계란으로 계란치기를 하는데
//한번 들어서 친 계란은 다시 들지 않고 바로 다음 계란으로 넘어가게 된다.
//대신 다음 차례들의 계란에 의해서 깨질 수는 있다.

//백트래킹을 활용해서 문제를 풀기로 결정했다.
//우선 전형적인 백트리킹 꼴을 갖춰놓고 총 8자리로 이루어지는 순열을 만든다.
//이 순열은 각 회차마다 들어올린 계란의 상대가 될 계란의 인덱스 위치가 된다.
//즉 최대 들어올려진 계란 본인을 제외한 나머지 계란들이 모두 상대가 될 수 있기 때문에
//최대 7^8=5,764,801 가지의 경우의 수가 나오는데 이는 충분히 2초의 시간 제한 안에 계산할 수 있는 양이다.

//이렇게 순열에 따라 직접 계란을 깨보면서 k=8이 되었을 때 내구도가 -가 되어있는 계란의 개수를 세고
//이 중 최대값을 찾으면 문제의 답이 될 것이다.

//여기서 주의할 점은 k가 증가해가며, 즉 백트래킹을 위한 재귀함수를 호출해가며 점점 내구도를 깎아갈텐데
//이게 재귀 호출이 끝나면 다시 원상 복구해줘야된다. (사실 백트래킹 방문 표시해줬다가 철회하는 거랑 다를 게 없음)

int n,answer;
int s[8];
int w[8];

void recursive(int k) { //순열의 k번째 인덱스를 채우는 재귀 함수. 인덱스는 0부터 시작한다.
    if(k==n) {
        int cnt = 0;
        for(int i=0; i<n; ++i) {
            if(s[i] <= 0)
                ++cnt;
        }
        answer = max(answer,cnt);
        return;
    }
    
    bool flag = false;
    for(int i=0; i<n; ++i) {    //현재 들고있는 k번째 계란과 부딪힐 상대와 부딪히는 과정
        if(k==i || s[i]<=0 || s[k]<=0)    //본인과 본인을 부딪히는 경우는 없으므로 skip, 혹은 상대할 계란이 깨졌을 경우에도 skip!
            continue;

        flag = true;
        s[k] -= w[i];
        s[i] -= w[k];
        recursive(k+1);
        s[k] += w[i];
        s[i] += w[k];
    }
    if(!flag)
        recursive(k+1); //이 부분에서 s[k] <= 0이라서 skip 되었던 부분들, 혹은 앞으로 깰 계란이 남지 않아 s[i]<=0라서 skip 된 부분에 대해서도 
    //다음 계란을 들도록 넘겨주는 것이다.
    //여기는 상대할 계란이 모두 깨졌거나, 현재 들고있는 계란이 깨진 경우에만 recursive(k+1)로 넘겨줘야한다.
    //왜나하면 이런 경우가 아니라면 위 for문 처럼 상대할 계란을 서로 깨고 넘겨줘야 되는게 맞기 때문이다.
}

int main(void) {
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    cin >> n;
    for(int i=0; i<n; ++i) {
        cin >> s[i] >> w[i];    //각 계란의 내구도와 무게를 기록
    }
    recursive(0);
    cout << answer;
    return 0;
}