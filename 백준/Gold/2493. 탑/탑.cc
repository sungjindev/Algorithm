#include <iostream>
#include <stack>
using namespace std;

//N은 최대 50만이다. 우선 가장 처음에 떠올릴 수 있는 알고리즘은 가장 오른쪽 탑에서부터 시작해서 자신보다 왼쪽에 있는 모든 탑들의 높이를
//탐색하며, 자신보다 높이가 높은 탑을 찾는 것이다. 이에 대한 시간 복잡도를 계산해보면 O(N*(N-1)/2) = 약 O(N^2)이다.
//따라서 O(500000^2) = O(250000000000)으로 시간 초과가 된다. 그래서 다른 알고리즘을 생각해야 하는데, 스택을 활용해볼 수 있다.
//여기서 중요한건 위 시간 초과가 발생한 주요 이유인, 이미 탐색한 곳을 계속 또 탐색하는 문제가 있다는 점을 해결해야 시간 초과 문제를
//해결할 수 있다.

//스택을 활용한 알고리즘은 다음과 같다. 우선 스택 하나를 두고 이 스택에 차곡 차곡 Input data들을 쌓아갈 것이다.
//여기서 핵심은 Top쪽에 가까울 수록 오른쪽에 있는 송수신탑이라는 것이고 우측에 있고 높이가 높으면 그 탑은 필요한 탑일 가능성이 높다.
//다시 말하면, 스택의 Top과 거리가 먼데 높이도 낮으면 스택의 Top과 가깝고 높이도 높은 송수신탑에 어차피 가려져 도달할 필요가 없어서
//의미가 없는 송수신탑이 된다. 따라서 이때는 스택에서 Pop을 해줄 것이다. 만약, 스택 Top에 가까운데 높이는 낮은 송수신탑이 있다면
//이건 필요한 송수신탑이다. 왜냐하면 스택 Top에 가깝다는 것이 1 우선순위이고, 다음에 들어올 송수신탑의 높이보다 크기만 하면 되므로
//의미있는 송수신탑이 될 수 있기 때문이다. 이 로직을 코드로 작성하면 아래 코드와 같다.

//참고적으로 아래 코드는 한 개의 스택에 대해서 많아봤자 1사이클(N)번에 대해 push, pop을 각 1회씩 수행하므로 시간 복잡도는 O(N)이다.

#define MAX 100000001   //송수신탑의 최대 높이+1

int main(void) {
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    stack<pair<int, int>> st1;  //{송수신탑 높이, 송수신탑 인덱스 번호}의 pair로 저장할 것이다.
    int temp, n=0;
    cin >> n;
    st1.push({MAX, 0});
    for(int i=1; i<=n; ++i) {
        cin >> temp;
        
        while(st1.top().first < temp) {
            st1.pop();
        }
        
        cout << st1.top().second << " ";
        st1.push({temp, i});
    }
    
    return 0;
}